
---@class cellPath
---@field cells tes3cell[] Cells in this path.
---@field doorCounts integer[] doorCounts[i] stores the number of times a door to `cells[i+1]` was found in `cells[i]`
-- In the optimized version, this field won't be stored.


-- Parameters to this function. In the final release, this will be generated by the documentation system.
---@class tes3cell.findBestPath.data
---@field targetCell tes3cell? The find a path to. Mutually exclusive with `closestExterior`.
---@field closestExterior boolean? Should we find a path to the closest exterior? Mutually exclusive with `targetCell`.
---@field limitToKnownCells boolean? Should we only check cells the player has visited before? Default: `true`.
---@field maxIterations number? The longest path length to consider. This is argument is less important when `closestExterior == true`. Default: 10

--- This implementation is horribly inefficient and unoptimized. But it is easier test :)
--- The final version will be rewritten in C++, and it will include some more checks for early returns.
--- In this version, a lot of paths get generated when routing between cells.
---@param self tes3cell This will eventually be a method on the `tes3cell` class.
---@param params tes3cell.findBestPath.data
---@return tes3cell[]|nil bestPath
---@return cellPath[] sortedPaths Only returned in prototype version. But I guess there could be an option to return all sorted paths in the final version too.
function tes3.tes3cell_findBestPath(self, params)

	---@type cellPath[]
	local paths = { {doorCounts = {}, cells = {self}} }

	---@param cell tes3cell The cell to test
	---@return boolean
	local function predicate(cell) error() end

	-- actual definition
	predicate = params.closestExterior and function(cell) return cell.isOrBehavesAsExterior end
										or function(cell) return cell.id == self.id end

	local i = 1
	while i <= #paths and i <= 500 do
		local path = paths[i]
		-- Only compute stuff if the path isn't too long 
		-- and if the path doesn't end in a cell that already satisfies the predicate.
		if #path.cells <= params.maxIterations
		and not predicate(path.cells[#path.cells]) 
		then
			---@type table<string, cellPath>
			local toExplore = {}
			
			for doorRef in path.cells[#path.cells]:iterateReferences(tes3.objectType.door, false) do	
				local dest = doorRef.destination and doorRef.destination.cell
				-- make sure the destination actually exists
				if dest == nil then
					goto nextDoor
				end

				if not dest.modified and params.limitToKnownCells then
					goto nextDoor
				end

				-- make sure this door doesn't lead to a place we've visited before in this path.
				for _, cell in ipairs(path.cells) do	
					if cell.id == dest.id then
						goto nextDoor
					end
				end

				if toExplore[dest.id] then
					local doorCounts = toExplore[dest.id].doorCounts
					doorCounts[#doorCounts] = doorCounts[#doorCounts] + 1
				else
					local newPath = {cells = table.copy(path.cells), doorCounts = table.copy(path.doorCounts)}
					table.insert(newPath.cells, dest)
					table.insert(newPath.doorCounts, 1)
					toExplore[dest.id] = newPath
				end
				::nextDoor::
			end

			for _, newPath in pairs(toExplore) do
				table.insert(paths, newPath)
			end
		end
		i = i + 1
	end

	-- filter out all the paths that didn't reach their destination.
	---@param path cellPath
	paths = table.filterarray(paths, function(_, path)
		return predicate(path.cells[#path.cells])
	end)


	--- Function that's used when sorting paths.
	---@param path cellPath
	local function scorePath(path)
		-- this is less about optimizing and more about being able to see it later when logging the results.
		if path.score then
			return path.score
		end

		-- Longer paths get a score penalty, compared to shorter paths.
		-- Conceptually, this line is the same as:
		-- local score = -1.5 * (#path.cells - shortestPathLength)
		local score = -1.5 * #path.cells

		for i, count in ipairs(path.doorCounts) do
			-- doors from cells visited later on count less than doors visited earlier
			-- Note: in the future this can be easily computed in the inner loop,
			-- to avoid pointless array copies. 
			-- But for now, it's nice to be able to see how many doors each path had.
			score = score + count / (0.75 * i)
		end
		path.score = score
		return score
	end

	
	---@param a cellPath
	---@param b cellPath
	table.sort(paths, function (a, b)
		return scorePath(a) > scorePath(b)
	end)

	-- return the list too so that we can see how all the paths compare to each other.
	return paths[1], paths
end
